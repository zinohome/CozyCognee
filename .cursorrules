# CozyCognee 项目规则

## 📚 文档组织规则（强制要求）

### 文档位置规则
- **所有文档必须放在 `docs/` 目录下**
- **禁止在项目根目录或其他目录创建文档文件（.md, .txt 等）**
- **README.md 文件例外：**
  - 项目根目录的 `README.md` 是项目主文档，允许存在
  - 各子目录的 `README.md` 用于说明该目录用途，允许存在
  - 但详细的技术文档、使用文档、开发文档等必须放在 `docs/` 目录下

### 文档目录结构
```
docs/
├── README.md                    # 文档索引和导航
├── PROJECT_STRUCTURE.md         # 项目结构说明
├── deployment/                  # 部署相关文档
│   └── README.md
├── development/                  # 开发相关文档
│   └── README.md
├── usage/                       # 使用相关文档
│   └── README.md
└── [其他分类]/                   # 按需添加其他分类
    └── README.md
```

### 文档命名规范
- 使用有意义的文件名，清晰描述文档内容
- 使用 kebab-case（短横线分隔）命名：`deployment-guide.md`
- 主要文档使用 `README.md` 作为文件名
- 避免使用中文文件名（内容可以使用中文）

### 文档分类原则
- **deployment/**: 部署、运维、配置相关文档
- **development/**: 开发环境、开发流程、代码规范相关文档
- **usage/**: 使用指南、API 文档、最佳实践相关文档
- **其他分类**: 根据项目需要添加，如 `api/`, `troubleshooting/`, `contributing/` 等

## 🚫 禁止的操作

1. **禁止在根目录创建文档文件**（除 README.md 外）
   - ❌ `根目录/部署指南.md`
   - ❌ `根目录/使用说明.md`
   - ✅ `docs/deployment/README.md`
   - ✅ `docs/usage/README.md`

2. **禁止在 deployment/ 目录下创建详细文档**
   - ❌ `deployment/部署说明.md`
   - ✅ `deployment/README.md`（简要说明）
   - ✅ `docs/deployment/README.md`（详细文档）

3. **禁止在项目根目录创建结构说明文档**
   - ❌ `根目录/PROJECT_STRUCTURE.md`
   - ✅ `docs/PROJECT_STRUCTURE.md`

## ✅ 正确的文档组织示例

### 示例 1: 添加新的部署文档
```
docs/
└── deployment/
    ├── README.md              # 主部署文档
    ├── docker-guide.md        # Docker 部署指南
    └── kubernetes-guide.md    # Kubernetes 部署指南
```

### 示例 2: 添加 API 文档
```
docs/
└── api/
    ├── README.md              # API 文档索引
    ├── rest-api.md            # REST API 文档
    └── mcp-api.md             # MCP API 文档
```

### 示例 3: 添加故障排查文档
```
docs/
└── troubleshooting/
    ├── README.md              # 故障排查索引
    ├── common-issues.md       # 常见问题
    └── error-codes.md        # 错误代码说明
```

## 📝 文档维护规则

1. **保持文档更新**: 代码变更时同步更新相关文档
2. **文档索引**: 在 `docs/README.md` 中维护文档索引
3. **交叉引用**: 使用相对路径进行文档间的交叉引用
4. **版本控制**: 重要变更在文档中记录版本信息

## 🔍 检查清单

创建或修改文档时，请确认：
- [ ] 文档是否放在 `docs/` 目录下的适当子目录？
- [ ] 是否在 `docs/README.md` 中添加了索引？
- [ ] 文件名是否符合命名规范？
- [ ] 是否避免了在根目录创建文档文件？

## 🎯 项目特定规则

### CozyCognee 项目文档分类
- **deployment/**: Docker Compose 部署、1Panel 部署、环境配置
- **development/**: 本地开发、Docker 开发、代码同步、构建镜像
- **usage/**: API 使用、前端使用、MCP 集成、最佳实践

### 文档链接规范
- 项目根目录 `README.md` 链接到 `docs/` 目录下的详细文档
- `docs/README.md` 作为文档导航中心
- 使用相对路径进行文档间链接

## 🚫 源代码修改规则（强制要求）

### 禁止修改 project 目录下的官方源代码
- **绝对禁止直接修改 `project/cognee/` 目录下的任何源代码文件**
- `project/cognee/` 目录包含的是 cognee 官方源代码，必须保持原样
- 任何对官方源代码的修改都应该通过 Docker 构建时的补丁机制实现

### 补丁机制
如果需要修改官方源代码，必须使用以下方式：

1. **在 Docker 构建时打补丁**
   - 补丁文件应放在 `deployment/docker/cognee/patches/` 目录下
   - 在 Dockerfile 中使用补丁脚本应用补丁
   - 参考现有补丁示例：`deployment/docker/cognee/patch_cors.py`

2. **补丁文件命名规范**
   - 补丁文件应清晰描述修改内容
   - 例如：`patch_cors.py`, `patch_error_handling.py`

3. **补丁脚本要求**
   - 补丁脚本应该是幂等的（可以安全地多次运行）
   - 补丁脚本应该包含回滚机制（如果可能）
   - 补丁脚本应该记录修改内容

### 允许修改的目录
- ✅ `deployment/` - 部署配置和 Docker 相关文件
- ✅ `docs/` - 文档文件
- ✅ `scripts/` - 项目脚本
- ✅ `deployment/docker/*/patches/` - 补丁文件

### 禁止修改的目录
- ❌ `project/cognee/cognee/` - Cognee 后端官方源代码
- ❌ `project/cognee/cognee-frontend/` - Cognee 前端官方源代码
- ❌ `project/cognee/cognee-mcp/` - Cognee MCP 官方源代码
- ❌ `project/cognee/` 下的任何其他官方源代码目录

### 补丁示例
参考现有的 CORS 补丁：
- 补丁脚本：`deployment/docker/cognee/patch_cors.py`
- 补丁文件：`deployment/docker/cognee/patches/cognee/`
- Dockerfile 中应用：在构建时运行补丁脚本

### 检查清单
修改代码前，请确认：
- [ ] 是否在修改 `project/cognee/` 目录下的文件？
- [ ] 如果是，是否应该使用补丁机制？
- [ ] 补丁文件是否放在正确的位置？
- [ ] 补丁脚本是否在 Dockerfile 中正确应用？

## ⚠️ 重要提醒

**所有文档必须放在 `docs/` 目录下并按子目录整理！**

**绝对禁止直接修改 `project/cognee/` 目录下的官方源代码！**

违反此规则的文件将被视为不符合项目规范，需要在代码审查时修正。

## 🐍 Python SDK 开发规则（强制要求）

### SDK 项目结构规范

#### 标准项目结构
```
cognee-sdk/
├── cognee_sdk/              # 主包目录
│   ├── __init__.py          # 公共 API 导出
│   ├── client.py            # 主客户端类
│   ├── models.py            # Pydantic 数据模型
│   ├── exceptions.py        # 自定义异常
│   ├── auth.py              # 认证相关
│   ├── api/                 # API 端点封装
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── data.py
│   │   └── ...
│   └── utils.py             # 工具函数
├── tests/                   # 测试代码
├── examples/                # 示例代码
├── pyproject.toml          # 项目配置
└── README.md               # 项目文档
```

#### 文件命名规范
- 使用 `snake_case` 命名 Python 文件：`cognee_client.py`
- 使用 `PascalCase` 命名类：`CogneeClient`
- 使用 `snake_case` 命名函数和变量：`get_datasets()`
- 使用 `UPPER_CASE` 命名常量：`DEFAULT_TIMEOUT`

### 代码风格和类型提示

#### 类型提示要求（强制）
- **所有函数必须包含完整的类型提示**
- 使用 `typing` 和 `typing_extensions` 模块
- 使用 `Optional[T]` 表示可选类型
- 使用 `Union[T1, T2]` 表示联合类型
- 使用 `List[T]`, `Dict[K, V]` 等泛型类型

```python
# ✅ 正确示例
from typing import Optional, List, Dict, Union, Any
from uuid import UUID

async def add(
    self,
    data: Union[str, bytes, Path, BinaryIO, List[Union[str, bytes, Path, BinaryIO]]],
    dataset_name: Optional[str] = None,
    dataset_id: Optional[UUID] = None,
    node_set: Optional[List[str]] = None
) -> AddResult:
    """添加数据到 Cognee"""
    pass

# ❌ 错误示例（缺少类型提示）
async def add(self, data, dataset_name=None, dataset_id=None):
    pass
```

#### 文档字符串要求（强制）
- **所有公共类、方法、函数必须包含 docstring**
- 使用 Google 风格或 NumPy 风格的 docstring
- 必须包含参数说明、返回值说明、异常说明

```python
# ✅ 正确示例
async def search(
    self,
    query: str,
    search_type: SearchType = SearchType.GRAPH_COMPLETION,
    datasets: Optional[List[str]] = None,
    top_k: int = 10
) -> List[SearchResult]:
    """
    搜索知识图谱
    
    Args:
        query: 搜索查询字符串
        search_type: 搜索类型，默认为 GRAPH_COMPLETION
        datasets: 数据集名称列表，可选
        top_k: 返回结果数量，默认为 10
    
    Returns:
        搜索结果列表
    
    Raises:
        AuthenticationError: 认证失败
        ValidationError: 请求参数验证失败
        ServerError: 服务器错误
    
    Example:
        >>> client = CogneeClient(api_url="http://localhost:8000")
        >>> results = await client.search("What is Cognee?")
    """
    pass
```

### 异步编程规范

#### 异步函数要求
- **所有 API 调用方法必须是异步的**（使用 `async def`）
- 使用 `httpx.AsyncClient` 进行 HTTP 请求
- 使用 `asyncio` 进行并发操作
- 正确使用 `await` 关键字

```python
# ✅ 正确示例
import httpx
import asyncio

class CogneeClient:
    def __init__(self, api_url: str):
        self.client = httpx.AsyncClient(timeout=300.0)
    
    async def search(self, query: str) -> List[SearchResult]:
        response = await self.client.post(
            f"{self.api_url}/api/v1/search",
            json={"query": query}
        )
        return response.json()
    
    async def close(self) -> None:
        await self.client.aclose()

# ❌ 错误示例（使用同步客户端）
import requests

class CogneeClient:
    def search(self, query: str):
        response = requests.post(...)  # 同步调用
        return response.json()
```

#### 并发操作支持
- 支持使用 `asyncio.gather()` 进行并发请求
- 提供批量操作方法（如 `add_batch()`）

```python
# ✅ 正确示例
async def add_batch(
    self,
    data_list: List[Union[str, bytes, Path]],
    dataset_name: str
) -> List[AddResult]:
    """批量添加数据"""
    tasks = [
        self.add(data, dataset_name=dataset_name)
        for data in data_list
    ]
    return await asyncio.gather(*tasks)
```

### 错误处理规范

#### 异常层次结构
- 定义清晰的异常层次结构
- 所有异常继承自 `CogneeSDKError`
- 根据 HTTP 状态码抛出相应的异常

```python
# ✅ 正确示例
class CogneeSDKError(Exception):
    """SDK 基础异常"""
    pass

class CogneeAPIError(CogneeSDKError):
    """API 调用错误"""
    def __init__(
        self,
        message: str,
        status_code: int,
        response: Optional[dict] = None
    ):
        self.message = message
        self.status_code = status_code
        self.response = response
        super().__init__(f"[{status_code}] {message}")

class AuthenticationError(CogneeAPIError):
    """认证错误（401）"""
    pass

class NotFoundError(CogneeAPIError):
    """资源未找到（404）"""
    pass

class ValidationError(CogneeAPIError):
    """请求验证错误（400）"""
    pass

class ServerError(CogneeAPIError):
    """服务器错误（5xx）"""
    pass
```

#### 错误处理实现
- 在 `_request()` 方法中统一处理错误
- 根据 HTTP 状态码抛出相应的异常
- 提供详细的错误信息

```python
# ✅ 正确示例
async def _handle_error_response(self, response: httpx.Response) -> None:
    """处理错误响应"""
    try:
        error_data = response.json()
        error_message = error_data.get("error") or error_data.get("detail") or response.text
    except:
        error_message = response.text
    
    status_code = response.status_code
    
    if status_code == 401:
        raise AuthenticationError(error_message, status_code, error_data)
    elif status_code == 404:
        raise NotFoundError(error_message, status_code, error_data)
    elif status_code == 400:
        raise ValidationError(error_message, status_code, error_data)
    elif status_code >= 500:
        raise ServerError(error_message, status_code, error_data)
    else:
        raise CogneeAPIError(error_message, status_code, error_data)
```

### API 设计原则

#### 方法命名规范
- 使用动词命名方法：`add()`, `delete()`, `search()`, `list_datasets()`
- 使用清晰的方法名，避免缩写
- 保持与 REST API 端点的一致性

#### 参数设计原则
- 使用关键字参数提供默认值
- 使用 `Optional[T]` 表示可选参数
- 提供合理的默认值
- 使用枚举类型限制选项值

```python
# ✅ 正确示例
from enum import Enum

class SearchType(str, Enum):
    GRAPH_COMPLETION = "GRAPH_COMPLETION"
    RAG_COMPLETION = "RAG_COMPLETION"
    CHUNKS = "CHUNKS"

async def search(
    self,
    query: str,
    search_type: SearchType = SearchType.GRAPH_COMPLETION,
    datasets: Optional[List[str]] = None,
    top_k: int = 10
) -> List[SearchResult]:
    pass

# ❌ 错误示例（使用字符串常量）
async def search(
    self,
    query: str,
    search_type: str = "GRAPH_COMPLETION",  # 容易出错
    datasets: List[str] = None,  # 不应该使用可变默认值
) -> List[SearchResult]:
    pass
```

#### 返回值设计
- 使用 Pydantic 模型定义返回值类型
- 返回类型化的对象，而不是原始字典
- 提供清晰的返回值文档

```python
# ✅ 正确示例
from pydantic import BaseModel

class AddResult(BaseModel):
    """添加数据结果"""
    status: str
    message: str
    data_id: Optional[UUID] = None
    dataset_id: Optional[UUID] = None

async def add(...) -> AddResult:
    response = await self._request(...)
    return AddResult(**response.json())
```

### 数据模型规范

#### Pydantic 模型要求
- **所有数据模型必须使用 Pydantic BaseModel**
- 使用类型提示定义字段
- 提供字段描述和验证规则
- 使用 `Field()` 提供默认值和验证

```python
# ✅ 正确示例
from pydantic import BaseModel, Field
from uuid import UUID
from datetime import datetime

class Dataset(BaseModel):
    """数据集模型"""
    id: UUID
    name: str = Field(..., description="数据集名称")
    created_at: datetime
    updated_at: Optional[datetime] = None
    owner_id: UUID

class SearchRequest(BaseModel):
    """搜索请求模型"""
    query: str = Field(..., min_length=1, description="搜索查询")
    search_type: SearchType = Field(
        default=SearchType.GRAPH_COMPLETION,
        description="搜索类型"
    )
    top_k: int = Field(
        default=10,
        ge=1,
        le=100,
        description="返回结果数量"
    )
```

### HTTP 客户端配置

#### 连接池和超时配置
- 使用连接池提高性能
- 配置合理的超时时间
- 支持自定义配置

```python
# ✅ 正确示例
import httpx

class CogneeClient:
    def __init__(
        self,
        api_url: str,
        timeout: float = 300.0,
        max_retries: int = 3
    ):
        self.client = httpx.AsyncClient(
            timeout=httpx.Timeout(timeout, connect=10.0),
            limits=httpx.Limits(
                max_keepalive_connections=10,
                max_connections=20
            ),
            follow_redirects=True
        )
```

#### 重试机制
- 实现自动重试机制
- 支持指数退避
- 只对特定错误重试（如网络错误、5xx 错误）

```python
# ✅ 正确示例
import asyncio

async def _request(
    self,
    method: str,
    endpoint: str,
    **kwargs
) -> httpx.Response:
    """发送 HTTP 请求，带重试机制"""
    last_exception = None
    for attempt in range(self.max_retries):
        try:
            response = await self.client.request(method, endpoint, **kwargs)
            if response.status_code >= 400:
                await self._handle_error_response(response)
            return response
        except httpx.TimeoutException as e:
            last_exception = e
            if attempt < self.max_retries - 1:
                await asyncio.sleep(self.retry_delay * (2 ** attempt))  # 指数退避
            else:
                raise TimeoutError(f"Request timeout after {self.max_retries} attempts") from e
    raise last_exception
```

### 文件上传处理

#### 支持多种输入类型
- 支持字符串、字节、文件路径、文件对象
- 自动检测 MIME 类型
- 正确处理 multipart/form-data

```python
# ✅ 正确示例
from pathlib import Path
import mimetypes

async def add(
    self,
    data: Union[str, bytes, Path, BinaryIO, List[Union[str, bytes, Path, BinaryIO]]],
    dataset_name: Optional[str] = None
) -> AddResult:
    """添加数据，支持多种输入类型"""
    if not isinstance(data, list):
        data = [data]
    
    files = []
    for item in data:
        if isinstance(item, str):
            files.append(("data", ("data.txt", item.encode("utf-8"), "text/plain")))
        elif isinstance(item, bytes):
            files.append(("data", ("data.bin", item, "application/octet-stream")))
        elif isinstance(item, Path):
            file_path = Path(item)
            mime_type, _ = mimetypes.guess_type(str(file_path))
            with open(file_path, "rb") as f:
                files.append(("data", (file_path.name, f.read(), mime_type or "application/octet-stream")))
        # ... 处理其他类型
    
    response = await self._request(
        "POST",
        "/api/v1/add",
        files=files,
        data={"datasetName": dataset_name}
    )
    return AddResult(**response.json())
```

### 测试规范

#### 测试文件组织
- 测试文件放在 `tests/` 目录
- 测试文件命名：`test_*.py`
- 使用 `pytest` 和 `pytest-asyncio`

#### 测试要求
- **所有公共方法必须有单元测试**
- 使用 mock 对象模拟 HTTP 请求
- 测试正常情况和异常情况
- 测试覆盖率目标：≥ 80%

```python
# ✅ 正确示例
import pytest
from unittest.mock import AsyncMock, patch
from cognee_sdk import CogneeClient
from cognee_sdk.exceptions import AuthenticationError

@pytest.mark.asyncio
async def test_search_success():
    """测试搜索成功"""
    client = CogneeClient(api_url="http://localhost:8000")
    
    with patch.object(client.client, 'post') as mock_post:
        mock_post.return_value.json.return_value = [
            {"id": "1", "text": "result 1"}
        ]
        mock_post.return_value.status_code = 200
        
        results = await client.search("test query")
        assert len(results) == 1

@pytest.mark.asyncio
async def test_search_authentication_error():
    """测试认证错误"""
    client = CogneeClient(api_url="http://localhost:8000")
    
    with patch.object(client.client, 'post') as mock_post:
        mock_post.return_value.status_code = 401
        mock_post.return_value.json.return_value = {"error": "Unauthorized"}
        
        with pytest.raises(AuthenticationError):
            await client.search("test query")
```

### 依赖管理

#### 最小依赖原则
- **只包含必要的依赖**
- 使用 `pyproject.toml` 管理依赖
- 明确区分必需依赖和可选依赖

```toml
# ✅ 正确示例
[project]
name = "cognee-sdk"
version = "0.1.0"
dependencies = [
    "httpx>=0.25.0",
    "pydantic>=2.0.0",
    "typing-extensions>=4.0.0"
]

[project.optional-dependencies]
websocket = [
    "websockets>=12.0"
]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.0.0",
    "black>=23.0.0",
    "ruff>=0.1.0",
    "mypy>=1.0.0"
]
```

### 文档规范

#### README 要求
- 包含快速开始示例
- 包含完整的 API 文档链接
- 包含安装说明
- 包含常见问题解答

#### 代码示例
- 在 `examples/` 目录提供完整示例
- 每个示例文件包含清晰的注释
- 提供异步和同步使用示例

```python
# ✅ 正确示例（examples/basic_usage.py）
"""
Cognee SDK 基础使用示例

展示如何使用 Cognee SDK 进行基本操作：
1. 添加数据
2. 处理数据
3. 搜索数据
"""
import asyncio
from cognee_sdk import CogneeClient, SearchType

async def main():
    # 初始化客户端
    client = CogneeClient(
        api_url="http://localhost:8000",
        api_token="your-token-here"
    )
    
    try:
        # 添加数据
        result = await client.add(
            data="Cognee turns documents into AI memory.",
            dataset_name="my-dataset"
        )
        print(f"Added data: {result.data_id}")
        
        # 处理数据
        cognify_result = await client.cognify(datasets=["my-dataset"])
        print(f"Cognify status: {cognify_result.status}")
        
        # 搜索
        results = await client.search(
            query="What does Cognee do?",
            search_type=SearchType.GRAPH_COMPLETION
        )
        for result in results:
            print(result)
    
    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(main())
```

### 版本兼容性

#### Python 版本要求
- **支持 Python 3.10+**
- 使用 `python_requires` 在 `pyproject.toml` 中声明

```toml
[project]
python_requires = ">=3.10"
```

#### API 版本兼容性
- 支持向后兼容
- 使用版本号管理 API 变更
- 废弃的 API 提供迁移指南

### 检查清单

开发 SDK 功能时，请确认：
- [ ] 所有方法都有完整的类型提示
- [ ] 所有公共方法都有 docstring
- [ ] 所有方法都是异步的（使用 `async def`）
- [ ] 错误处理正确实现（抛出适当的异常）
- [ ] 数据模型使用 Pydantic 定义
- [ ] 有对应的单元测试
- [ ] 代码通过 linting 检查（ruff, mypy）
- [ ] 更新了相关文档和示例

## 🚫 源代码修改规则（强制要求）

### 禁止修改原项目源代码
- **绝对禁止直接修改 `project/cognee/` 目录下的任何源代码文件**
- `project/cognee/` 目录包含的是 cognee 官方源代码，必须保持原样
- 任何对官方源代码的修改都应该通过 Docker 构建时的补丁机制实现

### 补丁机制
如果需要修改 cognee 源代码，必须使用以下方式：

1. **在 Docker 构建时打补丁**
   - 补丁文件应放在 `deployment/cognee/patches/` 目录下
   - 在 Dockerfile 中使用补丁脚本应用补丁
   - 参考现有补丁示例（如果存在）

2. **补丁文件命名规范**
   - 补丁文件应清晰描述修改内容
   - 例如：`patch_cors.py`, `patch_error_handling.py`

3. **补丁脚本要求**
   - 补丁脚本应该是幂等的（可以安全地多次运行）
   - 补丁脚本应该包含回滚机制（如果可能）
   - 补丁脚本应该记录修改内容

### 允许修改的目录
- ✅ `deployment/` - 部署配置和 Docker 相关文件
- ✅ `docs/` - 文档文件
- ✅ `deployment/cognee/patches/` - 补丁文件

### 禁止修改的目录
- ❌ `project/cognee/` - Cognee 官方源代码
- ❌ `project/cognee/` 下的任何其他官方源代码目录

### 检查清单
修改代码前，请确认：
- [ ] 是否在修改 `project/cognee/` 目录下的文件？
- [ ] 如果是，是否应该使用补丁机制？
- [ ] 补丁文件是否放在正确的位置？
- [ ] 补丁脚本是否在 Dockerfile 中正确应用？

## ⚠️ SDK 开发重要提醒

**所有 SDK 代码必须遵循上述规范！**

**绝对禁止直接修改 `project/cognee/` 目录下的官方源代码！**

**违反规范将导致代码审查不通过！**

**在提交代码前，请运行所有检查：**
```bash
# 代码格式化
ruff format .

# 代码检查
ruff check .

# 类型检查
mypy cognee_sdk/

# 运行测试
pytest tests/
```

